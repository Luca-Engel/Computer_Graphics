<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>proposal</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="icg_report.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="project-report">Project Report</h1>
<h2 id="abstract">Abstract</h2>
<p>This project creates a fire simulation. For this simulation, particles spawn according to a gaussian function, adjust their size according to Bézier Curves, and dissipate after a while. Billboards are used for the particles to increase computational efficiency and noise functions combined with pictures create the texture of the particles. Using vectors representing the color, different types of firepits are rendered, such as blue or green fires. Additionally, the camera can follow predefined paths using Bézier Curves.</p>
<h2 id="technical-approach">Technical Approach</h2>
<h4 id="summary">Summary</h4>
<p>As a starting point, we started with the GL1 and PG1 homeworks that we did this year due to the fact that there was already a template for the camera, actors and a scene we found would be good that were defined in GL1 and there was already nice code on noise functions in the PG1 homework, so we thought it would be a good starting point for our project.</p>
<p>First, we started with the GL1 template and modified the actors such that we would have fire actors with the sun texture overlayed and position the particle spawning center at the origin of the scene.</p>
<p>To start simple, the fire particles were rendered using spheres and the start position was calculated using a random gaussian noise function. The particles decreased in size over time and moved away from the center. This was done using an array containing all the particles which were instanciated in a for loop. For each particle, a transformation matrix was allocated and the particle was added to the scene as an actor. The class FireParticlesMovement was created to compute the model_matrix and simulate the fire particles in the scene. The class SysRenderFireParticlesUnshaded is responsible for drawing the actors with ‘unshaded’ shader_type.</p>
<p>To increase the computation efficience, billboards were used. These were constructed out of 2 triangle meshes. Then, the fire particles were projected on them. This change was based on a billboarding homework from a previous year. To make sure the billboards are always oriented towards the camera, a matrix computation was added in FireParticlesMovement to correct the orientation of the billboards. To enable this computation, the camera position had to be added to the scene to have access to it in this class.</p>
<p>Additionally, make the fire simulation more realistic, blending of the particles was implemented. This results in particles becoming brighter if there are multiple ones behind each other. To do so, blending has been added in the ParticlesRenderer class to apply this change. The blending is composed of an attribute alpha which determines the degree of transparency that is applied to the pixels. The blending is based on the following resource: <a href="https://github.com/regl-project/regl/blob/master/API.md#blending">Blending Example</a>.</p>
<p>Also, to not ensure that black parts of the particles are not drawn, an if condition has been added in the fragment shader to ensure that pixels would not be drawn if the sum of their rgb colors was less than 0.1. Additionally, to change the bilboards to a round shape, a Gaussian filter has been added to create a mask and apply it to the texture where, again, pixels could then be discarded.</p>
<p>Smoke particles were added in a very similar way to the fire particles. Perlin noise functions were used to create their texture. This was based on the PG1 homework. For that, in noise.frag.glsl a function that computes a cloud texture was added. This texture is stored in a buffer that is used to create the smoke particles’ texture. Also for the smoke particles billboarding was used.</p>
<p>To make the scene more interesting, rocks were placed around the firepit. These rock meshes were downloaded from the <a href="https://www.turbosquid.com/3d-models/3d-short-flat-rocks-1909649">internet</a> and adapted and combined in Blender. These rocks are rendered thanks to the class SysRenderRockUnshaded where, the rocks were loaded from the .obj files and rendered in the scene. At first, the color of the rocks was created using the moon as texture but this was changed to a darker texture found <a href="https://www.shutterstock.com/image-photo/black-stone-concrete-texture-background-anthracite-1617633904">online</a> and then adapted to make the simulation more realistic.</p>
<figure>
<img src="images/rock_textures.png" width="700" alt="Rock meshes in the blender file" /><figcaption aria-hidden="true">Rock meshes in the blender file</figcaption>
</figure>
<p>Then, 4 new magic colored fire spots were added around the main realistic fire spot following the same procedure as the main fire pit but using different magic textures for the fire particles.</p>
<p>Finally, using Bézier curves, the camera’s movement could, in addition to the manual movement, be moved automatically. The Bézier curve was implemented by computing the interpolation of points using the deCasteljau’s algorithm in order to create a camera path following the curve automatically. The curve was also created by computing new camera angles and by giving a time of execution for the simulation of a curve.</p>
<h4 id="description-of-problems">Description of problems</h4>
<p>Our first problem was that our camera eye wasn’t pointing towards the origin of the scene where the fire simulation was displayed. To fix this, we created a camera_focus_translation_mat and multiplied it with mat_view and mat_turnable.</p>
<p>Our second problem was with the billboarding, the particles were successfully always looking at the camera but they would not have the same side looking up at all times but rotating around themselves. As discussed with the assistants, however, we left this problem out. Also, since our textures now are no longer squares, it is almost not noticible.</p>
<p>Our third problem was for the blending. We were not sure what parameters we should put for the dstAlpha attribute in the render as there was multiple possibilities. So we tried them all and decided that the choice ‘one minus src alpha’ was the one giving us the best result in our project.</p>
<p>Our fourth problem was the order in which the particles were drawn. By drawing particles in the back after drawing particles closer to the camera, the rendered fire had some darker elements where it should be bright (thanks to the blending). To fix this, we sorted the particles by distance to the camera before rendering them.</p>
<figure>
<img src="images/fire_not_sorted.png" height="300" alt="Result without sorting" /><figcaption aria-hidden="true">Result without sorting</figcaption>
</figure>
<figure>
<img src="images/fire_sorted.png" height="300" alt="Result with sorting" /><figcaption aria-hidden="true">Result with sorting</figcaption>
</figure>
<p>Our fifth problem was with the perlin noise function for the cloud texture. The texture was only on the top right corner of the image, so the smoke particles weren’t looking good since there was a lot of black parts. To solve this problem, we just discarded the region of the image texture where the color was black and adapted the noise function to create the clouds in the middle of the buffer.</p>
<p>Our sixth problem was that we also needed to blend the rocks of the firepit with the fire to also enable smooth transitions between particles and the rocks. To do this, we drew the rocks before the particles.</p>
<figure>
<img src="images/particles_and_rocks_not_blending_because_the_rocks_are_drawn_last.png" height="300" alt="Result when drawing rocks after the particles (e.g., the smoke particle at the left does not have a smooth transition)" /><figcaption aria-hidden="true">Result when drawing rocks after the particles (e.g., the smoke particle at the left does not have a smooth transition)</figcaption>
</figure>
<figure>
<img src="images/particles_and_rocks_blending_because_the_rocks_are_drawn_first.png" height="300" alt="Result with drawing rocks before the particles" /><figcaption aria-hidden="true">Result with drawing rocks before the particles</figcaption>
</figure>
<h1 id="result">Result</h1>
<p>In the following, the results of this project are presented. <img src="images/final_result.png" width="700" alt="Snapshot of the fire simulation" /></p>
<figure>
<video src="images/ICG%20Project%2060fps.mp4" width="700" controls=""><a href="images/ICG%20Project%2060fps.mp4">Fire simulation</a></video><figcaption aria-hidden="true">Fire simulation</figcaption>
</figure>
<h1 id="zip-of-the-project">Zip of the project</h1>
<p>The zip archive of the sources files for the project can be found the folder.</p>
<h1 id="contribution-from-each-team-member">Contribution from each team member</h1>
<ul>
<li><p>Luca Engel : 0.35</p></li>
<li><p>Ahmad Jarrar : 0.40</p></li>
<li><p>Antoine Garin : 0.25</p></li>
</ul>
<h1 id="resources">Resources</h1>
<p>Here are some links that we found to be useful for our project :</p>
<ul>
<li><a href="http://www.opengl-tutorial.org/intermediate-tutorials/billboards-particles/particles-instancing/">OpenGL tutorial for the particles</a></li>
<li><a href="https://www.chinedufn.com/webgl-particle-effect-billboard-tutorial/">Particle effects via Billboards</a></li>
<li><a href="https://webglfundamentals.org/webgl/lessons/webgl-qna-efficient-particle-system-in-javascript---webgl-.html">WebGL fundamentals for writing particles in javascript</a></li>
<li><a href="https://groups.csail.mit.edu/graphics/classes/6.837/F99/projects/reports/team09.pdf">Some project report from MIT students</a></li>
<li><a href="https://www.shadertoy.com/view/lsdBD2">A fire effet simulation using GLSL</a></li>
<li><a href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending Tutorial</a></li>
<li><a href="https://github.com/regl-project/regl/blob/master/API.md#blending">Blending Example</a></li>
<li><a href="https://www.turbosquid.com/3d-models/3d-short-flat-rocks-1909649">Mesh used and adapted for rocks</a></li>
<li><a href="https://www.shutterstock.com/image-photo/black-stone-concrete-texture-background-anthracite-1617633904">Texture used and adapted for the rocks</a></li>
<li><a href="https://www.shutterstock.com/image-vector/abstract-green-blue-blurred-gradient-background-561604051">Texture used for the green_magic</a></li>
</ul>
<h1 id="file-containing-all-our-original-code">File containing all our original code</h1>
</body>
</html>
